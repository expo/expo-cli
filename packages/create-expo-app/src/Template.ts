import JsonFile from '@expo/json-file';
import * as PackageManager from '@expo/package-manager';
import spawnAsync from '@expo/spawn-async';
import chalk from 'chalk';
import getenv from 'getenv';
import ora from 'ora';
import path from 'path';

import { applyKnownNpmPackageNameRules, downloadAndExtractNpmModule } from './npm';

const isMacOS = process.platform === 'darwin';

const packageJSON = require('../package.json');

export type PackageManagerName = 'yarn' | 'npm';

function lodashMerge(target: any, source: any) {
  if (typeof target === 'object' && typeof source === 'object') {
    for (const key in source) {
      if (source.hasOwnProperty(key)) {
        lodashMerge(target[key], source[key]);
      }
    }
  } else {
    target = source;
  }
  return target;
}

/**
 * Extract a template app to a given file path and clean up any properties left over from npm to
 * prepare it for usage.
 */
export async function extractAndPrepareTemplateAppAsync(projectRoot: string) {
  const projectName = path.basename(projectRoot);

  await downloadAndExtractNpmModule(projectRoot, 'expo-template-blank', projectName);

  const config: Record<string, any> = {
    name: projectName,
    expo: {
      name: projectName,
      slug: projectName,
    },
  };

  const appFile = new JsonFile(path.join(projectRoot, 'app.json'));
  const appJson = lodashMerge(await appFile.readAsync(), config);
  await appFile.writeAsync(appJson);

  const packageFile = new JsonFile(path.join(projectRoot, 'package.json'));
  const packageJson = await packageFile.readAsync();
  // name and version are required for yarn workspaces (monorepos)
  const inputName = 'name' in config ? config.name : config.expo.name;
  packageJson.name = applyKnownNpmPackageNameRules(inputName) || 'app';
  // These are metadata fields related to the template package, let's remove them from the package.json.
  // A good place to start
  packageJson.version = '1.0.0';
  packageJson.private = true;
  delete packageJson.description;
  delete packageJson.tags;
  delete packageJson.repository;

  await packageFile.writeAsync(packageJson);

  return projectRoot;
}

export function validateName(name?: string): string | true {
  if (typeof name !== 'string' || name === '') {
    return 'The project name can not be empty.';
  }
  if (!/^[a-z0-9@.\-_]+$/i.test(name)) {
    return 'The project name can only contain URL-friendly characters.';
  }
  return true;
}

export async function initGitRepoAsync(
  root: string,
  flags: { silent: boolean } = { silent: false }
) {
  // let's see if we're in a git tree
  try {
    await spawnAsync('git', ['rev-parse', '--is-inside-work-tree'], { stdio: 'ignore', cwd: root });
    !flags.silent &&
      console.log(chalk.dim('New project is already inside of a Git repo, skipping git init.'));
  } catch (e: any) {
    if (e.errno === 'ENOENT') {
      !flags.silent && console.log(chalk.dim('Unable to initialize Git repo. `git` not in $PATH.'));
      return false;
    }
  }

  // not in git tree, so let's init
  try {
    await spawnAsync('git', ['init'], { stdio: 'ignore', cwd: root });
    await spawnAsync('git', ['add', '-A'], { stdio: 'ignore', cwd: root });
    const commitMsg = `Initial commit\n\nGenerated by ${packageJSON.name} ${packageJSON.version}.`;
    await spawnAsync('git', ['commit', '-m', commitMsg], {
      stdio: 'ignore',
      cwd: root,
    });

    !flags.silent && console.log(chalk.dim('Initialized a Git repository.'));
    return true;
  } catch {
    // no-op -- this is just a convenience and we don't care if it fails
    return false;
  }
}

export async function installDependenciesAsync(
  projectRoot: string,
  packageManager: PackageManagerName,
  flags: { silent: boolean } = { silent: false }
) {
  const options = { cwd: projectRoot, silent: flags.silent };
  if (packageManager === 'yarn') {
    const yarn = new PackageManager.YarnPackageManager(options);
    await yarn.installAsync();
  } else {
    await new PackageManager.NpmPackageManager(options).installAsync();
  }
}

export function logProjectReady({
  cdPath,
  packageManager,
}: {
  cdPath: string;
  packageManager: string;
}) {
  console.log(chalk.bold(`✅ Your project is ready!`));
  console.log();

  // empty string if project was created in current directory
  if (cdPath) {
    console.log(
      `To run your project, navigate to the directory and run one of the following ${packageManager} commands.`
    );
    console.log();
    console.log(`- ${chalk.bold('cd ' + cdPath)}`);
  } else {
    console.log(`To run your project, run one of the following ${packageManager} commands.`);
    console.log();
  }

  console.log(`- ${chalk.bold(packageManager === 'npm' ? 'npm run android' : 'yarn android')}`);

  let macOSComment = '';
  if (!isMacOS) {
    macOSComment =
      ' # you need to use macOS to build the iOS project - use the Expo app if you need to do iOS development without a Mac';
  }
  console.log(
    `- ${chalk.bold(packageManager === 'npm' ? 'npm run ios' : 'yarn ios')}${macOSComment}`
  );

  console.log(`- ${chalk.bold(packageManager === 'npm' ? 'npm run web' : 'yarn web')}`);
}

export async function installPodsAsync(projectRoot: string) {
  let step = logNewSection('Installing CocoaPods.');
  if (process.platform !== 'darwin') {
    step.succeed('Skipped installing CocoaPods because operating system is not on macOS.');
    return false;
  }
  const packageManager = new PackageManager.CocoaPodsPackageManager({
    cwd: path.join(projectRoot, 'ios'),
    silent: !getenv.boolish('EXPO_DEBUG', false),
  });

  if (!(await packageManager.isCLIInstalledAsync())) {
    try {
      step.text = 'CocoaPods CLI not found in your $PATH, installing it now.';
      step.render();
      await packageManager.installCLIAsync();
      step.succeed('Installed CocoaPods CLI');
      step = logNewSection('Running `pod install` in the `ios` directory.');
    } catch (e: any) {
      step.stopAndPersist({
        symbol: '⚠️ ',
        text: chalk.red(
          'Unable to install the CocoaPods CLI. Continuing with initializing the project, you can install CocoaPods afterwards.'
        ),
      });
      if (e.message) {
        console.log(`- ${e.message}`);
      }
      return false;
    }
  }

  try {
    await packageManager.installAsync();
    step.succeed('Installed pods and initialized Xcode workspace.');
    return true;
  } catch (e: any) {
    step.stopAndPersist({
      symbol: '⚠️ ',
      text: chalk.red(
        'Something went wrong running `pod install` in the `ios` directory. Continuing with initializing the project, you can debug this afterwards.'
      ),
    });
    if (e.message) {
      console.log(`- ${e.message}`);
    }
    return false;
  }
}

export function logNewSection(title: string) {
  const spinner = ora(chalk.bold(title));
  spinner.start();
  return spinner;
}
