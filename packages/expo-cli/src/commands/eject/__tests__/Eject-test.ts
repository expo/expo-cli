import fs from 'fs-extra';
import path from 'path';
import temporary from 'tempy';

import { isPkgMainExpoAppEntry, mergeGitIgnoreFiles, stripDashes } from '../Eject';

const testRoot = temporary.directory();

beforeAll(async () => {
  await fs.ensureDir(testRoot);
});
afterAll(async () => {
  await fs.remove(testRoot);
});

describe('mergeGitIgnore', () => {
  it(`skips merging if the target file is missing`, async () => {
    // fs
    const projectRoot = path.join(testRoot, 'merge-git-ignore-skip-when-target-missing');
    await fs.ensureDir(projectRoot);
    // Setup

    const targetGitIgnorePath = path.join(projectRoot, '.gitignore');
    // Skip writing a gitignore

    const sourceGitIgnorePath = path.join(projectRoot, '.gitignore-other');
    await fs.writeFile(
      sourceGitIgnorePath,
      [
        'alpha',
        'beta',
        // in the future we may want to merge this value with the existing matching value
        // or maybe we could keep the code simple and not do that :]
        'bar',
      ].join('\n')
    );

    expect(mergeGitIgnoreFiles(targetGitIgnorePath, sourceGitIgnorePath)).toBe(null);
    expect(fs.existsSync(targetGitIgnorePath)).toBe(false);
  });
  it(`merges two git ignore files in the filesystem`, async () => {
    // fs
    const projectRoot = path.join(testRoot, 'merge-git-ignore-works');
    await fs.ensureDir(projectRoot);
    // Setup
    const targetGitIgnorePath = path.join(projectRoot, '.gitignore');
    await fs.writeFile(
      targetGitIgnorePath,
      [
        'foo',
        // Test a duplicate value
        'bar',
      ].join('\n')
    );

    const sourceGitIgnorePath = path.join(projectRoot, '.gitignore-other');
    await fs.writeFile(
      sourceGitIgnorePath,
      [
        'alpha',
        'beta',
        // in the future we may want to merge this value with the existing matching value
        // or maybe we could keep the code simple and not do that :]
        'bar',
      ].join('\n')
    );

    const contents = mergeGitIgnoreFiles(targetGitIgnorePath, sourceGitIgnorePath);
    expect(contents).toMatch(/automatically generated by expo-cli/);
    expect(contents).toMatch(/foo/);
    expect(contents).toMatch(/alpha/);

    expect(fs.readFileSync(targetGitIgnorePath, 'utf8')).toBe(contents);
  });
});

describe('stripDashes', () => {
  it(`removes spaces and dashes from a string`, () => {
    expect(stripDashes(' My cool-app ')).toBe('Mycoolapp');
    expect(stripDashes(' --- - ----- ')).toBe('');
    expect(stripDashes('-----')).toBe('');
    expect(stripDashes(' ')).toBe('');
    expect(stripDashes(' \n-\n-')).toBe('');
  });
});

describe('isPkgMainExpoAppEntry', () => {
  it(`matches expo app entry`, () => {
    expect(isPkgMainExpoAppEntry('./node_modules/expo/AppEntry.js')).toBe(true);
    expect(isPkgMainExpoAppEntry('./node_modules/expo/AppEntry')).toBe(true);
    expect(isPkgMainExpoAppEntry('expo/AppEntry.js')).toBe(true);
    expect(isPkgMainExpoAppEntry('expo/AppEntry')).toBe(true);
  });
  it(`doesn't match expo app entry`, () => {
    expect(isPkgMainExpoAppEntry()).toBe(false);
    expect(isPkgMainExpoAppEntry(null)).toBe(false);
    expect(isPkgMainExpoAppEntry('./expo/AppEntry')).toBe(false);
    expect(isPkgMainExpoAppEntry('./expo/AppEntry.js')).toBe(false);
  });
});
