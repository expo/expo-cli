'use strict';
var __awaiter =
  (this && this.__awaiter) ||
  function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function(resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator['throw'](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
var __importDefault =
  (this && this.__importDefault) ||
  function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
Object.defineProperty(exports, '__esModule', { value: true });
const config_1 = require('@expo/config');
const image_utils_1 = require('@expo/image-utils');
const json_file_1 = __importDefault(require('@expo/json-file'));
const chalk_1 = __importDefault(require('chalk'));
const crypto_1 = __importDefault(require('crypto'));
const fs_extra_1 = require('fs-extra');
const glob_1 = __importDefault(require('glob'));
const path_1 = require('path');
const pretty_bytes_1 = __importDefault(require('pretty-bytes'));
const tempy_1 = __importDefault(require('tempy'));
function fileExists(file) {
  try {
    return fs_extra_1.statSync(file).isFile();
  } catch (_) {
    return false;
  }
}
// Read the contents of assets.json under .expo-shared folder. Create the file/directory if they don't exist.
function readAssetJsonAsync(projectDir) {
  return __awaiter(this, void 0, void 0, function*() {
    const dirPath = path_1.join(projectDir, '.expo-shared');
    fs_extra_1.ensureDirSync(dirPath);
    const assetJson = new json_file_1.default(path_1.join(dirPath, 'assets.json'));
    if (!fileExists(assetJson.file)) {
      console.log();
      console.log(
        chalk_1.default.magenta(
          `\u203A Creating ${chalk_1.default.bold(
            '.expo-shared/assets.json'
          )} in the project's root directory.`
        )
      );
      console.log(
        chalk_1.default
          .magenta`\u203A This file is autogenerated and should not be edited directly.`
      );
      console.log(
        chalk_1.default
          .magenta`\u203A You should commit this to git so that asset state is shared between collaborators.`
      );
      console.log();
      yield assetJson.writeAsync({});
    }
    const assetInfo = yield assetJson.readAsync();
    return { assetJson, assetInfo };
  });
}
// Compress an inputted jpg or png
function optimizeImageAsync(projectRoot, inputPath, quality) {
  return __awaiter(this, void 0, void 0, function*() {
    console.log(
      `\u203A Checking ${chalk_1.default.reset.bold(path_1.relative(projectRoot, inputPath))}`
    );
    const outputPath = tempy_1.default.directory();
    yield image_utils_1.sharpAsync({
      input: inputPath,
      output: outputPath,
      quality,
      // https://sharp.pixelplumbing.com/en/stable/api-output/#parameters_4
      adaptiveFiltering: true,
    });
    return path_1.join(outputPath, path_1.basename(inputPath));
  });
}
// Add .orig extension to a filename in a path string
function createNewFilename(imagePath) {
  const { dir, name, ext } = path_1.parse(imagePath);
  return path_1.join(dir, `${name}.orig${ext}`);
}
// Find all project assets under assetBundlePatterns in app.json excluding node_modules.
// If --include of --exclude flags were passed in those results are filtered out.
function getAssetFilesAsync(projectDir, options) {
  return __awaiter(this, void 0, void 0, function*() {
    const { exp } = yield config_1.readConfigJsonAsync(projectDir, true, true);
    const webOutputPath = yield config_1.getWebOutputPath(exp);
    const { assetBundlePatterns } = exp;
    const globOptions = {
      cwd: projectDir,
      ignore: ['**/node_modules/**', '**/ios/**', '**/android/**', `**/${webOutputPath}/**`],
    };
    // All files must be returned even if flags are passed in to properly update assets.json
    const allFiles = [];
    const patterns = assetBundlePatterns || ['**/*'];
    patterns.forEach(pattern => {
      allFiles.push(...glob_1.default.sync(pattern, globOptions));
    });
    // If --include is passed in, only return files matching that pattern
    const included =
      options && options.include
        ? [...glob_1.default.sync(options.include, globOptions)]
        : allFiles;
    const toExclude = new Set();
    if (options && options.exclude) {
      glob_1.default.sync(options.exclude, globOptions).forEach(file => toExclude.add(file));
    }
    // If --exclude is passed in, filter out files matching that pattern
    const excluded = included.filter(file => !toExclude.has(file));
    const filtered = options && options.exclude ? excluded : included;
    return {
      allFiles: filterImages(allFiles, projectDir),
      selectedFiles: filterImages(filtered, projectDir),
    };
  });
}
// Formats an array of files to include the project directory and filters out PNGs and JPGs.
function filterImages(files, projectDir) {
  const regex = /\.(png|jpg|jpeg)$/;
  const withDirectory = files.map(file => `${projectDir}/${file}`.replace('//', '/'));
  const allImages = withDirectory.filter(file => regex.test(file.toLowerCase()));
  return allImages;
}
// Calculate SHA256 Checksum value of a file based on its contents
function calculateHash(filePath) {
  const contents = fs_extra_1.readFileSync(filePath);
  return crypto_1.default
    .createHash('sha256')
    .update(contents)
    .digest('hex');
}
// Returns a boolean indicating whether or not there are assets to optimize
function isProjectOptimized(projectDir, options) {
  return __awaiter(this, void 0, void 0, function*() {
    if (!fileExists(path_1.join(projectDir, '.expo-shared/assets.json'))) {
      return false;
    }
    const { selectedFiles } = yield getAssetFilesAsync(projectDir, options);
    const { assetInfo } = yield readAssetJsonAsync(projectDir);
    for (const file of selectedFiles) {
      const hash = calculateHash(file);
      if (!assetInfo[hash]) {
        return false;
      }
    }
    return true;
  });
}
exports.isProjectOptimized = isProjectOptimized;
function optimizeAsync(projectRoot = './', options = {}) {
  return __awaiter(this, void 0, void 0, function*() {
    console.log();
    console.log(chalk_1.default.bold`\u203A Optimizing assets...`);
    const { assetJson, assetInfo } = yield readAssetJsonAsync(projectRoot);
    // Keep track of which hash values in assets.json are no longer in use
    const outdated = new Set();
    for (const fileHash in assetInfo) outdated.add(fileHash);
    let totalSaved = 0;
    const { allFiles, selectedFiles } = yield getAssetFilesAsync(projectRoot, options);
    const hashes = {};
    // Remove assets that have been deleted/modified from assets.json
    allFiles.forEach(filePath => {
      const hash = calculateHash(filePath);
      if (assetInfo[hash]) {
        outdated.delete(hash);
      }
      hashes[filePath] = hash;
    });
    outdated.forEach(outdatedHash => {
      delete assetInfo[outdatedHash];
    });
    const { include, exclude, save } = options;
    const quality = options.quality == null ? 80 : options.quality;
    const images = include || exclude ? selectedFiles : allFiles;
    for (const image of images) {
      const hash = hashes[image];
      if (assetInfo[hash]) {
        continue;
      }
      const { size: prevSize } = fs_extra_1.statSync(image);
      const newName = createNewFilename(image);
      const optimizedImage = yield optimizeImageAsync(projectRoot, image, quality);
      const { size: newSize } = fs_extra_1.statSync(optimizedImage);
      const amountSaved = prevSize - newSize;
      if (amountSaved > 0) {
        yield fs_extra_1.move(image, newName);
        yield fs_extra_1.move(optimizedImage, image);
      } else {
        assetInfo[hash] = true;
        console.log(
          chalk_1.default.dim(
            amountSaved === 0
              ? ` \u203A Skipping: Original was identical in size.`
              : ` \u203A Skipping: Original was ${pretty_bytes_1.default(
                  amountSaved * -1
                )} smaller.`
          )
        );
        continue;
      }
      // Recalculate hash since the image has changed
      const newHash = calculateHash(image);
      assetInfo[newHash] = true;
      if (save) {
        if (hash === newHash) {
          console.log(
            chalk_1.default.gray(
              `\u203A Compressed asset ${image} is identical to the original. Using original instead.`
            )
          );
          fs_extra_1.unlinkSync(newName);
        } else {
          console.log(chalk_1.default.gray(`\u203A Saving original asset to ${newName}`));
          // Save the old hash to prevent reoptimizing
          assetInfo[hash] = true;
        }
      } else {
        // Delete the renamed original asset
        fs_extra_1.unlinkSync(newName);
      }
      if (amountSaved) {
        totalSaved += amountSaved;
        console.log(chalk_1.default.magenta(`\u203A Saved ${pretty_bytes_1.default(amountSaved)}`));
      } else {
        console.log(chalk_1.default.gray(`\u203A Nothing to compress.`));
      }
    }
    console.log();
    if (totalSaved === 0) {
      console.log(chalk_1.default.yellow`\u203A All assets were fully optimized already.`);
    } else {
      console.log(
        chalk_1.default.bold(
          `\u203A Finished compressing assets. ${chalk_1.default.green(
            pretty_bytes_1.default(totalSaved)
          )} saved.`
        )
      );
    }
    assetJson.writeAsync(assetInfo);
  });
}
exports.optimizeAsync = optimizeAsync;
//# sourceMappingURL=assets.js.map
