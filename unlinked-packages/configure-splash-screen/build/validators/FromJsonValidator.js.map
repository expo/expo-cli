{"version":3,"file":"FromJsonValidator.js","sourceRoot":"","sources":["../../src/validators/FromJsonValidator.ts"],"names":[],"mappings":";;AAAA,mCAAkC;AAUlC;;GAEG;AACH,MAAqB,iBAAiB;IAAtC;QACE;;;;WAIG;QACK,UAAK,GAAgF,EAAE,CAAC;IAyElG,CAAC;IAvEC;;;;OAIG;IACH,OAAO,CAKL,IAA0C,EAC1C,qBAgBI,KAAK,CAAC,EAAE,CAAC,KAAK;QAElB,MAAM,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,CAAC,YAAY,CAAC,EAAE,EAAE,CAAC,YAAY,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;QAChG,IAAI,GAAG,KAAK,CAAC,CAAC,EAAE;YACd,aAAa;YACb,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC;SAC7C;aAAM;YACL,aAAa;YACb,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,IAAI,EAAE,kBAAkB,CAAC,CAAC;SAC9C;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED,KAAK,CAAC,QAAQ,CAAC,UAAgB;QAC7B,aAAa;QACb,MAAM,MAAM,GAAO,EAAE,CAAC;QACtB,MAAM,MAAM,GAA6B,EAAE,CAAC;QAC5C,KAAK,MAAM,CAAC,YAAY,EAAE,cAAc,CAAC,IAAI,IAAI,CAAC,KAAK,EAAE;YACvD,IAAI;gBACF,MAAM,QAAQ,GAAG,YAAG,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;gBAC/C,IAAI,QAAQ,KAAK,SAAS,EAAE;oBAC1B,iCAAiC;oBACjC,SAAS;iBACV;gBACD,MAAM,KAAK,GAAG,MAAM,cAAc,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;gBACrD,YAAG,CAAC,MAAM,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;aAClC;YAAC,OAAO,CAAC,EAAE;gBACV,MAAM,CAAC,IAAI,CAAC,CAAC,YAAY,EAAE,CAAC,CAAC,CAAC,CAAC;aAChC;SACF;QAED,IAAI,MAAM,CAAC,MAAM,GAAG,CAAC,EAAE;YACrB,MAAM,IAAI,KAAK,CAAC,sBAAsB,IAAI,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;SACpE;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IAEO,YAAY,CAAC,MAAgC;QACnD,OAAO,MAAM;aACV,GAAG,CAAC,CAAC,CAAC,YAAY,EAAE,KAAK,CAAC,EAAE,EAAE;YAC7B,OAAO,MAAM,YAAY,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,KAAK,CAAC,OAAO,EAAE,CAAC;QACjF,CAAC,CAAC;aACD,IAAI,CAAC,IAAI,CAAC,CAAC;IAChB,CAAC;CACF;AA/ED,oCA+EC","sourcesContent":["import { get, set } from 'lodash';\n\nimport type {\n  JsonShape,\n  OptionalPromise,\n  NonPrimitiveAndNonArrayKeys,\n  DeepRequired,\n  IsNever,\n} from './types';\n\n/**\n * This class is responsible for validating configuration object in a form of json and produce validated object based on validating `rules` added via `addRule` method.\n */\nexport default class FromJsonValidator<From extends JsonShape<To>, To extends object> {\n  /**\n   *  Records:\n   * - keys are stringified array paths to the properties\n   * - values are functions accepting\n   */\n  private rules: [PropertyKey[], (value: unknown, config: To) => OptionalPromise<unknown>][] = [];\n\n  /**\n   * Add rule that determined what property is copied from JSON object into actual validated object.\n   * @param name an array describing property path (just like in lodash.get function)\n   * @param validatingFunction optional parameter that is responsible for actual type conversion and semantic checking (e.g. check is given string is actually a path or a valid color). Not providing it results in copying over value without any semantic checking.\n   */\n  addRule<\n    TK1 extends NonPrimitiveAndNonArrayKeys<DeepRequired<To>>,\n    TK2 extends NonPrimitiveAndNonArrayKeys<DeepRequired<To>[TK1]>,\n    TK3 extends NonPrimitiveAndNonArrayKeys<DeepRequired<To>[TK1][TK2]>\n  >(\n    name: [TK1] | [TK1, TK2] | [TK1, TK2, TK3],\n    validatingFunction: (\n      value: IsNever<\n        TK3,\n        // @ts-ignore\n        IsNever<TK2, DeepRequired<From>[TK1], DeepRequired<From>[TK1][TK2]>,\n        // @ts-ignore\n        DeepRequired<From>[TK1][TK2][TK3]\n      >,\n      config: To\n    ) => OptionalPromise<\n      IsNever<\n        TK3,\n        IsNever<TK2, DeepRequired<To>[TK1], DeepRequired<To>[TK1][TK2]>,\n        DeepRequired<To>[TK1][TK2][TK3]\n      >\n      // @ts-ignore\n    > = value => value\n  ): this {\n    const idx = this.rules.findIndex(([propertyPath]) => propertyPath.join('.') === name.join('.'));\n    if (idx === -1) {\n      // @ts-ignore\n      this.rules.push([name, validatingFunction]);\n    } else {\n      // @ts-ignore\n      this.rules[idx] = [name, validatingFunction];\n    }\n    return this;\n  }\n\n  async validate(jsonConfig: From): Promise<To> {\n    // @ts-ignore\n    const config: To = {};\n    const errors: [PropertyKey[], Error][] = [];\n    for (const [propertyPath, validatingFunc] of this.rules) {\n      try {\n        const rawValue = get(jsonConfig, propertyPath);\n        if (rawValue === undefined) {\n          // No value for this propertyPath\n          continue;\n        }\n        const value = await validatingFunc(rawValue, config);\n        set(config, propertyPath, value);\n      } catch (e) {\n        errors.push([propertyPath, e]);\n      }\n    }\n\n    if (errors.length > 0) {\n      throw new Error(`Validating error:\\n${this.formatErrors(errors)}`);\n    }\n    return config;\n  }\n\n  private formatErrors(errors: [PropertyKey[], Error][]): string {\n    return errors\n      .map(([propertyPath, error]) => {\n        return `  '${propertyPath.map(el => String(el)).join('.')}': ${error.message}`;\n      })\n      .join('\\n');\n  }\n}\n"]}