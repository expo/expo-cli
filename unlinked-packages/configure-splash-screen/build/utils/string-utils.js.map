{"version":3,"file":"string-utils.js","sourceRoot":"","sources":["../../src/utils/string-utils.ts"],"names":[],"mappings":";;;AAAA,oBAAoB;AACpB,uCAAqC;AAErC;;GAEG;AACH,SAAgB,OAAO,CACrB,OAAe,EACf,EAAE,cAAc,EAAE,cAAc,EAA+D;IAE/F,MAAM,wBAAwB,GAAG,OAAO,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC;IAChE,IAAI,wBAAwB,KAAK,CAAC,CAAC,EAAE;QACnC,OAAO,CAAC,IAAI,EAAE,OAAO,CAAC,OAAO,CAAC,cAAc,EAAE,cAAc,CAAC,CAAC,CAAC;KAChE;IACD,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AAC1B,CAAC;AATD,0BASC;AAED;;;GAGG;AACH,SAAgB,MAAM,CACpB,OAAe,EACf,EAAE,aAAa,EAAE,aAAa,EAA6D,EAC3F,6BAAsC,KAAK;IAE3C,IAAI,0BAA0B,EAAE;QAC9B,OAAO,6BAA6B,CAAC,OAAO,EAAE,EAAE,aAAa,EAAE,aAAa,EAAE,CAAC,CAAC;KACjF;IACD,MAAM,uBAAuB,GAAG,OAAO,CAAC,MAAM,CAAC,aAAa,CAAC,CAAC;IAC9D,IAAI,uBAAuB,KAAK,CAAC,CAAC,EAAE;QAClC,OAAO;YACL,IAAI;YACJ,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,uBAAuB,CAAC,GAAG,aAAa,GAAG,OAAO,CAAC,KAAK,CAC1E,uBAAuB,CACxB,EAAE;SACJ,CAAC;KACH;IACD,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;AAC1B,CAAC;AAlBD,wBAkBC;AAED;;;GAGG;AACH,SAAS,6BAA6B,CACpC,OAAe,EACf,EAAE,aAAa,EAAE,aAAa,EAA6D;IAE3F,MAAM,OAAO,GAAG,CAAC,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,MAAM,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;IACvE,MAAM,qBAAqB,GAAG,OAAO,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;IAC1D,IAAI,CAAC,qBAAqB,EAAE;QAC1B,OAAO,CAAC,KAAK,EAAE,OAAO,CAAC,CAAC;KACzB;IACD,OAAO;QACL,IAAI;QACJ,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,qBAAqB,CAAC,KAAK,CAAC,GAAG,aAAa,GAAG,OAAO,CAAC,KAAK,CAC9E,qBAAqB,CAAC,KAAK,CAC5B,EAAE;KACJ,CAAC;AACJ,CAAC","sourcesContent":["// runtime polyfills\nimport 'core-js/es/string/match-all';\n\n/**\n * @returns [`true`, modifiedContent: string] if replacement is successful, [`false`, originalContent] otherwise.\n */\nexport function replace(\n  content: string,\n  { replaceContent, replacePattern }: { replaceContent: string; replacePattern: string | RegExp }\n): [boolean, string] {\n  const replacePatternOccurrence = content.search(replacePattern);\n  if (replacePatternOccurrence !== -1) {\n    return [true, content.replace(replacePattern, replaceContent)];\n  }\n  return [false, content];\n}\n\n/**\n * Inserts content just before first occurrence of provided pattern.\n * @returns [`true`, modifiedContent: string] if insertion is successful, [`false`, originalContent] otherwise.\n */\nexport function insert(\n  content: string,\n  { insertContent, insertPattern }: { insertContent: string; insertPattern: RegExp | string },\n  insertBeforeLastOccurrence: boolean = false\n): [boolean, string] {\n  if (insertBeforeLastOccurrence) {\n    return insertBeforeLastOccurrenceFun(content, { insertContent, insertPattern });\n  }\n  const insertPatternOccurrence = content.search(insertPattern);\n  if (insertPatternOccurrence !== -1) {\n    return [\n      true,\n      `${content.slice(0, insertPatternOccurrence)}${insertContent}${content.slice(\n        insertPatternOccurrence\n      )}`,\n    ];\n  }\n  return [false, content];\n}\n\n/**\n * Finds last occurrence of provided pattern and inserts content just before it.\n *@returns [`true`, modifiedContent: string] if insertion is successful, [`false`, originalContent] otherwise.\n */\nfunction insertBeforeLastOccurrenceFun(\n  content: string,\n  { insertContent, insertPattern }: { insertContent: string; insertPattern: RegExp | string }\n): [boolean, string] {\n  const results = [...content.matchAll(new RegExp(insertPattern, 'gm'))];\n  const patternLastOccurrence = results[results.length - 1];\n  if (!patternLastOccurrence) {\n    return [false, content];\n  }\n  return [\n    true,\n    `${content.slice(0, patternLastOccurrence.index)}${insertContent}${content.slice(\n      patternLastOccurrence.index\n    )}`,\n  ];\n}\n"]}