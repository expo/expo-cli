{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/xml-manipulation/index.ts"],"names":[],"mappings":"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","sourcesContent":["import deepEqual from 'deep-equal';\nimport { Element, js2xml, xml2js, Attributes } from 'xml-js';\n\nimport {\n  readFileWithFallback,\n  createDirAndWriteFile,\n  removeFileIfExists,\n} from '../utils/file-utils';\n\ntype ExplicitNewValue<T> = { newValue: T };\ntype WithExplicitNewValue<T> = T | ExplicitNewValue<T>;\n\ntype ExpectedElementAttributes = Record<string, WithExplicitNewValue<string | number | undefined>>;\ntype WithExplicitIndex<T> = T & { idx?: number };\ntype WithDeletionFlag<T> = T & { deletionFlag?: boolean };\n\ntype ExpectedElements = WithExplicitNewValue<\n  WithExplicitIndex<WithDeletionFlag<ExpectedElement>>[]\n>;\n\nexport type ExpectedElementType = {\n  name: string;\n  attributes?: ExpectedElementAttributes;\n  elements?: ExpectedElements;\n};\n\nexport type ExpectedElementsType = {\n  elements: ExpectedElements;\n};\n\nexport type ExpectedCommentType = {\n  comment: string;\n};\n\nexport type ExpectedTextType = {\n  text: string | number | boolean;\n};\n\nexport type ExpectedElement =\n  | ExpectedElementType\n  | ExpectedElementsType\n  | ExpectedCommentType\n  | ExpectedTextType;\n\nfunction isElementType(el: ExpectedElement): el is ExpectedElementType {\n  return (el as ExpectedElementType).name !== undefined;\n}\n\nfunction isElementsType(el: ExpectedElement): el is ExpectedElementsType {\n  return !(el as ExpectedElementType).name && Boolean((el as ExpectedElementsType).elements);\n}\n\nfunction isCommentType(el: ExpectedElement): el is ExpectedCommentType {\n  return (el as ExpectedCommentType).comment !== undefined;\n}\n\nfunction isTextType(el: ExpectedElement): el is ExpectedTextType {\n  return (el as ExpectedTextType).text !== undefined;\n}\n\nfunction isExplicitNewValue<T>(el: WithExplicitNewValue<T>): el is ExplicitNewValue<T> {\n  // @ts-ignore\n  return typeof el === 'object' && el.hasOwnProperty('newValue');\n}\n\nfunction unboxExplicitNewValue<T>(el: WithExplicitNewValue<T>): T {\n  return isExplicitNewValue(el) ? el.newValue : el;\n}\n\nfunction compareElements(element: Element, expectedElement: ExpectedElement): boolean {\n  if (isTextType(expectedElement)) {\n    return element.type === 'text';\n  }\n\n  if (isCommentType(expectedElement)) {\n    return element.type === 'comment' && element.comment?.trim() === expectedElement.comment.trim();\n  }\n\n  if (isElementType(expectedElement) && element.type === 'element') {\n    if (expectedElement.name !== element.name) {\n      return false;\n    }\n\n    if (!element.attributes) {\n      return true;\n    }\n\n    for (const [key, value] of Object.entries(\n      (expectedElement as ExpectedElementType).attributes || {}\n    )) {\n      if (isExplicitNewValue(value)) {\n        // this attribute has to be overridden\n        continue;\n      }\n      if (element.attributes[key] !== value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  return false;\n}\n\nfunction sortWithExplicitIndex<T>(elements?: WithExplicitIndex<T>[]): T[] | undefined {\n  if (!elements) {\n    return;\n  }\n  const result: T[] = new Array(elements.length);\n  const elementsWithExplicitIndices = elements.filter(({ idx }) => idx !== undefined);\n  const elementsWithoutExplicitIndices = elements.filter(({ idx }) => idx === undefined);\n  elementsWithoutExplicitIndices.forEach((el, idx) => (result[idx] = el));\n  elementsWithExplicitIndices.forEach(({ idx, ...el }, i) => {\n    // @ts-ignore\n    result.splice(idx ?? i, 0, el);\n  });\n  return result;\n}\n\nfunction mergeXmlElementsLists(\n  current?: Element[],\n  expected?: ExpectedElements\n): Element[] | undefined {\n  if (isExplicitNewValue(expected) || !current) {\n    const sortedExpected = sortWithExplicitIndex(unboxExplicitNewValue(expected));\n    return sortedExpected?.map(convertToElement);\n  }\n  if (!expected) {\n    return current;\n  }\n\n  const result: WithExplicitIndex<WithDeletionFlag<Element>>[] = [];\n\n  for (const currentElement of current) {\n    const idxInExpected = expected.findIndex(el => compareElements(currentElement, el));\n    if (idxInExpected !== -1) {\n      const { idx, ...element } = expected.splice(idxInExpected, 1)[0];\n      if (!element.deletionFlag) {\n        result.push({ idx, ...mergeXmlElements(currentElement, element) });\n      }\n    } else {\n      result.push(currentElement);\n    }\n  }\n  result.push(\n    ...expected\n      .filter(({ deletionFlag }) => !deletionFlag)\n      .map(({ idx, ...el }) => ({ idx, ...convertToElement(el) }))\n  );\n  const sortedResult = sortWithExplicitIndex(result);\n  return sortedResult;\n}\n\nfunction convertToElement({\n  idx,\n  ...expectedElement\n}: WithExplicitIndex<ExpectedElement>): Element {\n  // @ts-ignore\n  if (expectedElement.deletionFlag) {\n    throw new Error('Cannot convert ExpectedElement to Element when deletionFlag is set');\n  }\n\n  if (isCommentType(expectedElement)) {\n    return {\n      ...expectedElement,\n      type: 'comment',\n    };\n  }\n  if (isTextType(expectedElement)) {\n    return {\n      ...expectedElement,\n      type: 'text',\n    };\n  }\n  if (isElementsType(expectedElement)) {\n    return {\n      elements: unboxExplicitNewValue(expectedElement.elements)\n        .filter(({ deletionFlag }) => !deletionFlag)\n        .map(convertToElement),\n      type: 'element',\n    };\n  }\n  const { elements, attributes, ...expectedRest } = expectedElement;\n  const result: Element = {\n    ...expectedRest,\n    type: 'element',\n  };\n  if (attributes) {\n    result.attributes = convertExpectedAttributes(attributes);\n  }\n  if (elements) {\n    result.elements = unboxExplicitNewValue(elements)\n      .filter(({ deletionFlag }) => !deletionFlag)\n      .map(convertToElement);\n  }\n  return result;\n}\n\nfunction convertExpectedAttributes(\n  expectedAttributes?: ExpectedElementAttributes\n): Attributes | undefined {\n  if (expectedAttributes) {\n    const result = Object.entries(expectedAttributes).reduce(\n      (acc, [key, value]) => ({\n        ...acc,\n        [key]: unboxExplicitNewValue(value),\n      }),\n      {}\n    );\n    return result;\n  }\n  return undefined;\n}\n\nfunction mergeAndConvertToElement(\n  { attributes: currentAttributes, ...currentRest }: Omit<Element, 'elements'>,\n  { attributes: expectedAttributes, ...expectedRest }: Omit<ExpectedElementType, 'elements'>\n): Element {\n  const result: Element = {\n    ...currentRest,\n    ...expectedRest,\n  };\n  const attributes = (currentAttributes || expectedAttributes) && {\n    ...currentAttributes,\n    ...convertExpectedAttributes(expectedAttributes),\n  };\n  if (attributes) {\n    result.attributes = attributes;\n  }\n  return result;\n}\n\n/**\n * Assumption is that elements are `equal` semantically\n */\nexport function mergeXmlElements(current: Element, expected: ExpectedElement): Element {\n  if (isCommentType(expected)) {\n    return {\n      ...current,\n      ...expected,\n      type: 'comment',\n    };\n  }\n\n  if (isTextType(expected)) {\n    return {\n      ...current,\n      ...expected,\n      type: 'text',\n    };\n  }\n\n  if (isElementsType(expected)) {\n    const result = {\n      ...current,\n      type: 'element',\n    };\n    const elements = mergeXmlElementsLists(current.elements, expected.elements);\n    if (elements) {\n      result.elements = elements;\n    }\n    return result;\n  }\n\n  const { elements: currentElements, ...currentRest } = current;\n  const { elements: expectedElements, ...expectedRest } = expected;\n\n  const elements = mergeXmlElementsLists(current.elements, expected.elements);\n  const result = {\n    ...mergeAndConvertToElement(currentRest, expectedRest),\n    type: 'element',\n  };\n  if (elements) {\n    result.elements = elements;\n  }\n  return result;\n}\n\n/**\n * @param filePath\n * @param fallbackContent\n */\nexport async function readXmlFile(\n  filePath: string,\n  fallbackContent: Element | string = `<?xml version=\"1.0\" encoding=\"utf-8\"?>`\n): Promise<Element> {\n  const fileContent = await readFileWithFallback(\n    filePath,\n    typeof fallbackContent === 'string' ? fallbackContent : 'fallbackToElement'\n  );\n  if (fileContent === 'fallbackToElement' && typeof fallbackContent === 'object') {\n    return fallbackContent;\n  }\n  const fileXml = xml2js(fileContent);\n  return fileXml as Element;\n}\n\nexport async function writeXmlFile(filePath: string, xml: Element) {\n  const fileXml = js2xml(xml, { indentAttributes: true, spaces: 2 });\n  const correctedFile = fileXml.replace(\n    /(?<openTag><[^\\s]+)\\n *(?<firstAttribute> [^\\s]+=\".+?\")\\n *((?<secondAttribute> [^\\s]+=\".+?\")\\n *)?(?<closeTag>[/?]?>)/g,\n    '$1$2$4$5'\n  );\n  await createDirAndWriteFile(filePath, `${correctedFile}\\n`);\n}\n\n/**\n * Checks whether two xmlElements are equal in terms of their structure\n */\nexport function xmlElementsEqual(\n  a: Element,\n  b: Element,\n  { disregardComments = true }: { disregardComments?: boolean } = {}\n): boolean {\n  const filteredA = !disregardComments ? a : removeComments(a);\n  const filteredB = !disregardComments ? b : removeComments(b);\n  return deepEqual(filteredA, filteredB);\n}\n\nfunction removeComments(e: Element): Element | undefined {\n  if (e.type === 'comment') {\n    return;\n  }\n  const result = Object.entries(e)\n    .map(([key, value]): [string, any] => {\n      if (key === 'elements' && Array.isArray(value)) {\n        const filteredValue = value\n          .map(removeComments)\n          .filter((el): el is Element => el !== undefined);\n        return [key, filteredValue.length > 0 ? filteredValue : undefined];\n      }\n      return [key, value];\n    })\n    .filter(([_, value]) => value !== undefined)\n    .reduce((acc, [key, value]) => {\n      // @ts-ignore\n      acc[key] = value;\n      return acc;\n    }, {});\n  return result;\n}\n\n/**\n * Check if given `element` has some meaningful data:\n * - if so: write it to the file\n * - if no: remove file completely\n * Function assumes that the structure of the input `element` is correct (`element.elements[name = resources]`).\n */\nexport async function writeXmlFileOrRemoveFileUponNoResources(\n  filePath: string,\n  element: Element,\n  { disregardComments }: { disregardComments?: boolean } = {}\n) {\n  if (\n    element.elements?.[0].name === 'resources' &&\n    element.elements[0].elements?.filter(({ type }) =>\n      disregardComments ? type !== 'comment' : true\n    ).length === 0\n  ) {\n    await removeFileIfExists(filePath);\n  } else {\n    await writeXmlFile(filePath, element);\n  }\n}\n"]}